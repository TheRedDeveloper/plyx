//! Google Fonts integration â€” search the popularity-sorted font list and download.
//!
//! The font list is a JSON array of family name strings, pre-sorted by
//! popularity (index 0 = most popular). It is generated by `buildfontlist.sh`
//! and committed to the plyx repo. At runtime we fetch it from GitHub,
//! cache it locally, and use it for search / selection.
//!
//! Font files are downloaded as zip archives from fonts.google.com.

use std::path::{Path, PathBuf};

const FONT_LIST_URL: &str =
    "https://raw.githubusercontent.com/TheRedDeveloper/plyx/refs/heads/main/fontlist.json";

fn cache_dir() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    PathBuf::from(home).join(".cache").join("plyx")
}

fn cache_path() -> PathBuf {
    cache_dir().join("fontlist.json")
}

fn fetch_font_list() -> Result<Vec<String>, String> {
    println!("Fetching Google Fonts catalog...");

    let response = ureq::get(FONT_LIST_URL)
        .call()
        .map_err(|e| format!("Failed to fetch font list: {e}"))?;

    let body = response
        .into_body()
        .read_to_string()
        .map_err(|e| format!("Failed to read response: {e}"))?;

    serde_json::from_str(&body).map_err(|e| format!("Failed to parse font list: {e}"))
}

/// Load the popularity-sorted font list.
///
/// Always tries to fetch the latest list from GitHub. If the fetch fails
/// (e.g. offline), falls back to a locally cached copy.
pub fn load_font_list() -> Result<Vec<String>, String> {
    match fetch_font_list() {
        Ok(fonts) => {
            // Update cache on success
            let dir = cache_dir();
            std::fs::create_dir_all(&dir).ok();
            if let Ok(json) = serde_json::to_string(&fonts) {
                std::fs::write(cache_path(), json).ok();
            }
            Ok(fonts)
        }
        Err(fetch_err) => {
            // Fall back to cache
            let path = cache_path();
            if path.exists() {
                eprintln!("Warning: Could not fetch latest font list, using cached version.");
                let data = std::fs::read_to_string(&path)
                    .map_err(|e| format!("Failed to read cache: {e}"))?;
                serde_json::from_str(&data)
                    .map_err(|e| format!("Failed to parse cache: {e}"))
            } else {
                Err(fetch_err)
            }
        }
    }
}

/// Search fonts by name (case-insensitive substring match).
/// Results preserve popularity order.
pub fn search<'a>(fonts: &'a [String], query: &str) -> Vec<&'a str> {
    let query_lower = query.to_lowercase();
    fonts
        .iter()
        .filter(|f| f.to_lowercase().contains(&query_lower))
        .map(|f| f.as_str())
        .collect()
}

/// Find a font by exact name (case-insensitive).
pub fn find_by_name<'a>(fonts: &'a [String], name: &str) -> Option<&'a str> {
    let name_lower = name.to_lowercase();
    fonts
        .iter()
        .find(|f| f.to_lowercase() == name_lower)
        .map(|f| f.as_str())
}

/// Suggested fonts shown at the top of the selection list during `plyx init`.
/// These are displayed when the user hasn't typed a search query.
pub const SUGGESTED_FONTS: &[&str] = &[
    "Lexend", // This should have the text " (Default)" next to it
    "Inter",
    "Roboto",
    "Open Sans",
    "Montserrat",
    "Nunito",
];

/// Download a font from Google Fonts by family name.
///
/// Uses the Google Fonts CSS API to discover the direct .ttf URL, then
/// downloads the font file from fonts.gstatic.com.
pub fn download(family: &str, dest_dir: &Path) -> Result<PathBuf, String> {
    std::fs::create_dir_all(dest_dir)
        .map_err(|e| format!("Failed to create {}: {e}", dest_dir.display()))?;

    println!("Downloading {family}...");

    // Fetch the CSS from Google Fonts API. Using a User-Agent without woff2
    // support makes Google serve direct .ttf URLs.
    let css_url = format!(
        "https://fonts.googleapis.com/css2?family={}",
        family.replace(' ', "+")
    );

    let agent = ureq::Agent::new_with_defaults();
    let mut css_response = agent
        .get(&css_url)
        .header("User-Agent", "plyx/0.1")
        .call()
        .map_err(|e| format!("Failed to fetch font CSS for {family}: {e}"))?;

    let css = css_response
        .body_mut()
        .read_to_string()
        .map_err(|e| format!("Failed to read CSS response: {e}"))?;

    // Parse the CSS to find the .ttf URL. The CSS contains @font-face rules like:
    //   src: url(https://fonts.gstatic.com/s/lexend/v23/...ttf) format('truetype');
    // We look for the first URL ending in .ttf (weight 400 / regular).
    let ttf_url = extract_ttf_url(&css)
        .ok_or_else(|| format!("No .ttf URL found in CSS for {family}. CSS:\n{css}"))?;

    let mut font_response = agent
        .get(ttf_url)
        .call()
        .map_err(|e| format!("Failed to download font file: {e}"))?;

    let ttf_bytes = font_response
        .body_mut()
        .with_config()
        .limit(20 * 1024 * 1024) // 20MB limit
        .read_to_vec()
        .map_err(|e| format!("Failed to read font file: {e}"))?;

    let filename = family.to_lowercase().replace(' ', "_") + ".ttf";
    let dest_path = dest_dir.join(&filename);

    std::fs::write(&dest_path, &ttf_bytes)
        .map_err(|e| format!("Failed to write {}: {e}", dest_path.display()))?;

    println!("  Saved to {}", dest_path.display());
    Ok(dest_path)
}

/// Extract the first .ttf URL from Google Fonts CSS.
fn extract_ttf_url(css: &str) -> Option<&str> {
    // Look for url(...ttf) patterns
    for segment in css.split("url(") {
        if let Some(end) = segment.find(')') {
            let url = &segment[..end];
            if url.ends_with(".ttf") {
                return Some(url);
            }
        }
    }
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_ttf_url() {
        let css = r#"
@font-face {
  font-family: 'Lexend';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/lexend/v23/abc.ttf) format('truetype');
}
"#;
        let url = extract_ttf_url(css);
        assert_eq!(url, Some("https://fonts.gstatic.com/s/lexend/v23/abc.ttf"));
    }

    #[test]
    fn test_extract_ttf_url_no_match() {
        let css = "@font-face { src: url(https://example.com/font.woff2); }";
        assert_eq!(extract_ttf_url(css), None);
    }

    #[test]
    fn test_download_lexend() {
        let tmp = std::env::temp_dir().join("plyx_test_download");
        let _ = std::fs::remove_dir_all(&tmp);

        let result = download("Lexend", &tmp);
        assert!(result.is_ok(), "Download failed: {:?}", result.err());

        let path = result.unwrap();
        assert!(path.exists(), "Font file not created");
        assert!(
            std::fs::metadata(&path).unwrap().len() > 1000,
            "Font file too small"
        );
        assert_eq!(path.file_name().unwrap(), "lexend.ttf");

        let _ = std::fs::remove_dir_all(&tmp);
    }
}

/// Default font name.
pub const DEFAULT_FONT: &str = "Lexend";
